# 文档1：C++中如何抽象线程的？

## 什么是 `std::thread`

​	std::thread是C++11后引入进来的标准库线程类，用于表示一个独立执行的线程实体，定义在 `<thread>` 头文件中，现在，使用C++编程不再需要使用pthread库或者是Windows Native进行封装了，而是直接使用基于RAII的`<thread>`来完成我们的工作，这个我想没有什么太大的争议。

​	`std::thread`是急式的对象，当我们调用了std::thread对象之后，线程会立即开始运行指定的可调用实体（函数、lambda 等）。若该可调用在运行中抛出未捕获的异常，程序将调用 `std::terminate()`。线程的返回值也被忽略，若需获取结果，可使用 `std::promise/std::future` 等手段传递值或异常（如果觉得太高级了，可以自己传递一个结构体的引用，或者像类的对象成员安全写入信息。这个话题会在锁，信号量等话题再次见面）

## 基本用法

#### 创建线程

​	C++中创建一个线程非常的简单，我们知道线程需要传递一个执行的函数体，线程才会有东西值得执行，不然我们为什么会需要线程呢？对吧！

```cpp
#include <thread>
#include <iostream>

void task(const std::string& msg) {
    std::cout << "Task says: " << msg << "\n";
}

int main() {
    std::thread t(task, "Hello");
    t.join(); // 等待线程结束
}
```

上述代码中，线程在构造时启动，主线程随后调用 `join()` 阻塞直至线程结束。

#### `join()` 与 `detach()`

​	join和detach是线程派发后的两种策略，如果我们期待再一个点后强迫线程执行结束后才继续，好像我们再等待分叉出去的线程的汇入，这就是join，对于detach，则是说明我们完全撒手不管了线程，直接扔出去，注意的是，这个线程的生命周期就是你没法控制的了，所以detach用的极少，一般都是一些后台线程才会使用detach，默默的干活。

- **`join()`**：使主线程等待子线程执行完成。若线程对象在析构时仍处于可 `joinable()` 状态且未被 `join` 或 `detach`，程序将调用 `std::terminate()`。
- **`detach()`**：将线程与 `std::thread` 对象分离，使其在后台继续运行，资源在结束时自动释放，无法再次 `join()`。
- 可使用 `joinable()` 检查线程是否仍可被 `join`

### 传参规则（值拷贝 vs 引用）

- 默认情况下，传递给线程函数的参数会被按值拷贝/移动到线程上下文中。
- 若希望传递引用，需使用 `std::ref()` 或 `std::cref()` 包装，才能正确传递引用类型参数；未包装则按值复制，可能导致不可预期行为

------

## 线程身份和线程对象管理

- `get_id()`：获取 `std::thread` 对应的线程 ID，用于打印或比较。
- `native_handle()`：访问底层平台线程句柄（如 POSIX `pthread_t` 等），便于与原生 API 集成

线程对象不可复制，但支持移动：

```cpp
std::thread t1(task);
std::thread t2 = std::move(t1); // t1 变为空线程对象
```

之后应对 `t2` 调用 `join()` 或 `detach()`

------

## 硬件并发能力查询

```cpp
unsigned hc = std::thread::hardware_concurrency();
```

返回一个 hint 值，代表系统支持的硬件并行线程数，但不是确切保证值，只做参考使用

------

## 线程使用总结表

| 功能             | 使用示例                              | 说明               |
| ---------------- | ------------------------------------- | ------------------ |
| 创建线程         | `std::thread t(func, args...)`        | 启动新线程         |
| 等待线程结束     | `t.join()`                            | 主线程阻塞等待     |
| 分离线程         | `t.detach()`                          | 后台运行无法 join  |
| 检查是否可 join  | `t.joinable()`                        | 判断线程状态       |
| 传递引用参数     | `std::ref(obj)`                       | 按引用传递线程参数 |
| 获取线程 ID      | `t.get_id()`                          | 打印或比较线程标识 |
| 底层线程句柄访问 | `t.native_handle()`                   | 与原生 API 集成    |
| 硬件线程数量提示 | `std::thread::hardware_concurrency()` | 查询并发能力       |

------

